\input hhletter                     % format for 8.5 by 11 paper
%\input hhsmall                      % format for viewing on phones and tablets

%\usepackage{hyperref}              % causes yap to not preview .dvi files
\newcommand{\url}[1]{{\tt #1}}      % clumsy workaround

\begin{document}

\renewcommand{\baselinestretch}{1.1}

\begin{center} \mbox{\sc
R and RStudio tutorial - Math 4450/5450 - Spring 2015 - Zirbel}\\
\end{center}

\renewcommand{\blist}[1]{\begin{list}{{\arabic{enumi}:}}{\usecounter{enumi}\setlength{\itemsep}{#1}}}
\renewcommand{\elist}{\end{list}}

R is a programming language that is used for statistics.
RStudio is an Integrated Development Environment (IDE), a place where you can edit R programs, run them, and keep track of the variables in the programs and the graphics windows that R produces.

\minorheading{Installing R and RStudio}

If you installed R a long time ago, you might want to uninstall it and install the most recent version.  I just installed version 3.1.2.

To install R, go to \url{http://cran.rstudio.com/}, find your platform, and pick your way through the links that get R installed.  Generally, you would rather use compiled binaries than source code, tarballs, or anything like that.

To install RStudio, go here:  \url{http://www.rstudio.com/products/rstudio/download/} and look for the section called {\bf Download RStudio Desktop v0.98.1091} or some higher-numbered version.
I suggest that you find the Installer for your platform, click that, wait patiently, and install it.

When you start RStudio, the window will be divided into sub-windows.
One of these is the Console window, with the prompt $>$.
The commands below should be typed at the prompt.
Don't type the line numbers or the comments at the ends of the lines.

\minorheading{R basics}
\blist{-0.05in}
\vspace{-0.1in}
\item {\tt 2*9}       \hfill R can be used as a calculator.
\item {\tt exp(1)} \hfill The exponential function.
\item {\tt 2\^{}999}
\item {\tt x=exp(1)}  \hfill You can store values with variable names.
\new This sets the value of {\tt x} equal to {\tt exp(1)}.
\item {\tt x}         \hfill This displays the value of {\tt x}
\item {\tt x <- exp(1)} \hfill Alternate way to assign a value to {\tt x}, often used by people writing about R.  \new But why use two characters when one will do?
\item {\tt x=runif(10)} \hfill {\tt x} is a collection of 10 random
numbers, uniformly distributed between 0 and 1. \new {\tt x} is like a row
of cells in a spreadsheet.  It is called a {\bf vector}.
\item {\tt x+5}       \hfill Add 5 to each entry of {\tt x}.
\item {\tt 1000*x}       \hfill Multiply each entry of {\tt x} by 100.
\item {\tt round(150*x)} \hfill Round to the nearest integer.
\item {\tt ceiling(100*x)} \hfill Round up to the next integer. This is how you generate \new random numbers uniformly distributed from 1 to 100.
\item {\tt x=runif(100)} \hfill Go ahead, try something larger than 100.
\item {\tt max(x)} \hfill
\item {\tt mean(x)} \hfill
\item {\tt sum(x)} \hfill
\item {\tt median(x)} \hfill
\item {\tt sort(x)} \hfill Sort x in increasing order.
\item {\tt cumsum(x)} \hfill A vector of cumulative sums of entries of {\tt x}.
\item {\tt P = matrix(0,ncol=20,nrow=20)} \hfill Examine {\tt P} to see what you get.
\item {\tt rowSums(P)} \hfill Calculate the sums of the rows of {\tt P}.
\item {\tt P[1,2] = 0.5} \hfill Set one value in the matrix {\tt P}.

\minorheadinginlist{Plotting points and histograms}
\item {\tt plot(x,pch=16)} \hfill Plot the values of {\tt x} against numbers 1, 2, ... as filled dots.
\item {\tt plot(cumsum(x),type="l")} \hfill Plot the cumulative sum against the numbers 1, 2, ..., \new connecting points with lines.
\item {\tt dev.off()} \hfill Clear the plotting window.
\item {\tt hist(x)} \hfill Make a histogram of the values of {\tt x}.
\item {\tt hist(x,breaks=20)} \hfill Use 20 bins instead of the default 10.
\item {\tt y=-log(x)} \hfill Take the natural logarithm of the entries of
{\tt x}.
\item {\tt hist(y,breaks=20)} \hfill Looks like an exponential distribution.  It will look better \new with more data points, so re-define {\tt x} and do it again.

\item {\tt ?hist} \hfill To get help, type ? followed by the name of a command.  Sometimes \new you can guess what you want and then read about it.  Or google your question.

\item {\tt up arrow} \hfill Press the up arrow to return to previous commands, hit enter to run them again.
\item {\tt control-L)} \hfill On a PC, clear all the old commands in the console window.
\item {\tt cat("\textbackslash 014")} \hfill On a Mac, clear all the old commands in the console window.

\minorheadinginlist{Downloading R programs for random processes from Github}
\item I have posted a number of R programs on Github.  To find them, google ``Github zirbel random processes'' or go to \url{https://github.com/clzirbel/Random\_Processes} and find the Download Zip button or go straight to \url{https://github.com/clzirbel/Random\_Processes/archive/master.zip} to get the .zip file.
Unzip the file and save it in an accessible place.

\item In RStudio, use the File, Open File menu to navigate to where you unzipped the programs from Github, then find the R folder within it, and open the file {\tt gambler\_outcome.R}.  It will open in an editor window.  It is a good idea to read the commands in it and start to understand what they do.  I have added many comments to the commands in the file, separated from the commands by the \# character.

\item {\tt getwd()} \hfill Figure out what R considers to be the working directory.  This is where it looks for programs and where it writes out files.  I suggest that you use the directory where you have downloaded and unzipped files from Github.  The easiest way to change the working directory is to go to the Session menu, Set Working Directory, To Source File Location if you have already opened a file.  Or, use Choose Directory.

\item {\tt source("gambler\_outcome.R")} \hfill The source function will load the file and run the commands in it.  Make sure you have the working directory set right.  Instead of typing this, you can click the button that says Source in the upper right of the editor window.  The program simulates gambler's wealth for 80 steps.  If the game goes longer than that, it does all the remaining steps at once.  (I could not figure out how to get R to extend the axes dynamically.)

\item Run the program {\tt gambler\_outcome.R} multiple times, then quit.  In the program, find the line that pauses after each step, set the pause time to 0.0, and then source it again.  Now each game will take just a moment to generate and draw, and you can get a better sense of what they look like.

\minorheadinginlist{R functions}
\item In RStudio, use File, Open File to open {\tt source("gambler\_functions.R")}.  Use the Source button on the upper right of the editor window to have RStudio load the file and run the commands in it.
  
\item {\tt P = gambler\_transition\_matrix()} \hfill Set up the transition matrix for Gambler's wealth.
\item {\tt P} \hfill Show the matrix.

\item {\tt P = gambler\_transition\_matrix(10,20,0.5)} \hfill Specifically tell R what initial wealth, opponent wealth, and win probability to use.  Check that {\tt P} looks the same.

\item {\tt P = gambler\_transition\_matrix(5,5,0.7)} \hfill Set up a transition matrix for a different gambling situation.  Look at {\tt P} now.

\item Read through the file {\tt gambler\_functions.R}.  There are several function definitions, for example, this one:  {\tt gambler_transition_matrix = function(m=10,n=20,p=0.5)}.  It says that there are three inputs, which will be called {\tt m, n,} and {\tt p} within the function.  If the user does not give values for them, the default values will be 10, 20, and 0.5, respectively.



\minorheadinginlist{Matrix operations and plotting}

\item {\tt install.packages("expm")} \hfill Do this once to install the package on your computer.
\item {\tt library(expm)} \hfill Do this once per R session to use the expm library, which allows R to calculate matrix powers.  If you source matrix\_functions.R (see below), then this is done for you.
\item {\tt install.packages("gplots")} \hfill Do this once to install the package on your computer.
\item {\tt source("matrix\_functions.R")} \hfill Load functions for matrix calculations.

\item {\tt print\_matrix(P)} \hfill Show the matrix so that it can be copied and pasted into another program easily.

\item {\tt transition\_matrix\_powers(P,0)} \hfill Show six powers of P.  If you get ``Error in plot.new() : figure margins too large'' try making the figure window larger.

\item {\tt P \%\^\% 20} \hfill Calculate the 20th power of P.  This uses the expm package.

\item {\tt pdf("filename.pdf",width=8.5,height=11)} \hfill If you want to save a plot as a PDF, type this command, then make the plot, and then do the next command to actually write the file.
\item {\tt dev.off()} \hfill Do this after plotting.




\item {\tt hist(y,30)} \hfill Most of the values of {\tt y} are near 0, but
some are as large as 6.  The numbers in {\tt y} have what is called the
{\bf exponential distribution}.
\item {\tt x=rand(10000,1)} \hfill You typed a command similar to this a
while ago.  Type {\tt x=} and then the up arrow to bring it back, then edit
it to change 100 to 10000.
\item {\tt z=randn(1000,1);} \hfill Generate 1000 normally distributed numbers
\item {\tt hist(z,30)} \hfill The histogram is bell--shaped.  You might
want to try this with more than 1000 numbers.

\hspace*{-0.5in}
{\bf Getting some Matlab programs}

\item Launch Internet Explorer and open {\tt
www-math.bgsu.edu/\~{}zirbel/chem694} 
This site contains brief descriptions of all the programs and links to
those programs.

\item Click the link for {\tt allfiles.tar}.

\item Internet Explorer's Download Manager will appear and the file
{\tt allfiles.tar} will be stored in some strange folder somewhere.

\item In Download Manager, double click {\tt allfiles.tar}, then click on
the button Reveal in Finder.  Now you can see where {\tt allfiles.tar} was
put.

\item Stuffit Expander should have already untarred the file {\tt
allfiles.tar} and put the various files it contains into a folder called
something like allfiles Folder.

\item Drag this folder onto the desktop.  If you look at the contents, you
will see a bunch of .m files, which the Macintosh incorrectly assumes are
Mathematica files.

\item Start Matlab by pulling down the Apple menu, Applications, Matlab
5.2.

\item In Matlab, File, Open, Desktop, allfiles Folder, and select something
like dice.m.

\item Once you have opened one program from this folder, you can run any
program from this folder by typing its name in the Matlab command window.

\hspace*{-0.5in}
{\bf Coin flipping}

\item {\tt 3<5} \hfill The answer is 1 because the inequality is satisfied.
\item {\tt 5<3} \hfill The answer is 0.
\item {\tt x>0.5} \hfill Check the inequality for each entry of x.  
\item {\tt z=1+(x>0.5)} \hfill {\tt z} will equal 1 or 2.  This is
like flipping coins, with 1 for heads and 2 for tails.
\item {\tt show(z,'HT')} \hfill Use a program called {\tt show},
which needs two arguments, a vector of integers greater than 0 and a string
to tell what letters to use to display each number.
\item {\tt show(1+(rand(1500,1)>0.5),'HT')} \hfill Generate 1500 coin
flips.  Now press the up arrow and return, repeatedly.  That's a lot of
coin flips!  What is the longest run of heads that you can find?
\item {\tt show(1+(rand(1500,1)>0.5),'O-')} \hfill You can make that
question easier to answer with different characters.  Use the up arrow so
you can simply edit the previous command.

This works well enough for coin flipping, in which there are only two
outcomes.  But for other random experiments like rolling a die, a program
called {\tt rando.m} is more useful.

\item {\tt d=[1 1 1 1 1 1]/6} \hfill A row vector (1 by 6 matrix)
of probabilities for the outcomes of rolling a die.
\item {\tt sum(d)} \hfill Make sure these sum to 1!
\item {\tt rando(d)} \hfill Use these probabilities to simulate rolls of a
die.  Use the up arrow to repeat this command several times.

\hspace*{-0.5in}
{\bf Writing a Matlab program}

We are going to create a new Matlab program called {\tt dna\_roll.m}, which
will simulate a sequence of A,C,G,T which is supposed to look like DNA.

At the top of the command window is a blank white sheet; click on that to
open a new editor window.
In that window, type the commands below on separate lines, then save the
program as {\tt dna\_roll.m} by clicking on the disk icon.

\item {\tt dna=[1 1 1 1]/4;} \hfill Probabilities for each of the four letters.
\item {\tt for i=1:400} \hfill What comes next will be repeated 400 times.
\item {\tt ~~x(i) = rando(dna);} \hfill Generate a number from 1 to 4.
\item {\tt end} \hfill The end of the commands to repeat 400 times.
\item {\tt show(x,'ACGT')} \hfill Translate the numbers into these letters.
\item {\tt hist(x,4)} \hfill Histogram the four values in {\tt x}.

Back in the command window, type {\tt dna\_roll} to run the program, then
the up arrow to run it again and again.
If there is an error, check to see that you have typed everything correctly.

\item {\tt show(1+(x==1),' A')} \hfill For fun, display just the {\tt
A} entries.  Can you get just the {\tt T}'s?

We might want to simulate sequences in which {\tt A} occurs twice as
often as any other letter.
To do this, modify the definition of the vector {\tt dna} and then run the
program a bunch of times.

\item {\tt dna=[2 1 1 1]/5;} \hfill The entries still sum to 1.

\hspace*{-0.5in}
{\bf Markov chains}

\item {\tt M=rand(6,6)} \hfill A 6 by 6 matrix of random numbers.
\item {\tt M(2,:)} \hfill Pull out the second row of the matrix.
\item {\tt M(:,4)} \hfill Pull out the fourth column of the matrix.
\item {\tt diag(M)} \hfill Pull out the diagonal entries of the matrix.
\item {\tt sum(M)} \hfill Sum the columns of the matrix.
\item {\tt sum(M')'} \hfill Sum the rows of the matrix.  The apostrophe
denotes {\bf transpose}.

So far, each letter in the sequence has no relation or dependence to the
letters before it, just like when you flip a coin or roll a die.
The letters are said to be {\bf independent}.

However, we should be able to set up a situation in which an {\tt A} is
usually followed by an {\tt A} but never by a {\tt T}.
After the letter {\tt A}, we could use the vector {\tt [0.6 0.2 0.2 0]} to
choose the next letter.
After the letter {\tt C}, we could use a {\bf different} vector, etc.

To do this, we'll create a new program called {\tt dna\_markov.m}.
Open a new editor window and type the following commands.
Note that the vector for the Markov chain is called Pi, as in the textbook.

\item {\tt A=[[0.6 0.2 0.2 0]; [0 0.6 0.2 0.2]; [0.2 0 0.6 0.2]; [0.2 0.2 0
0.6]];} \hfill {\tt A} is a 4 by 4 matrix.
Each row tells the probabilities we are going to use for the next letter.
Row 1 tells what probabilities to use after the number 1 (corresponding to
the letter {\tt A}), row 2 tells what probabilities to use after the number
2 (for {\tt C}), and so on.
\item {\tt Pi(1) = rando([1 1 1 1]/4);} \hfill Choose the first state randomly.
\item {\tt for i=1:399,} \hfill
\item {\tt ~~Pi(i+1) = rando(A(Pi(i),:));} \hfill Pull out row {\tt Pi(i)} of
the matrix {\tt A} and use these as the probabilities to generate the next
state. 
\item {\tt end} \hfill
\item {\tt show(Pi,'ACGT');} \hfill
\item {\tt hist(Pi,4);} \hfill

After you run this a few times, you might want to be able to generate
longer strings of letters all at once.
A good way to do that is to make {\tt dna\_markov.m} into a {\bf Matlab
function}, so that you can call it with a parameter (pass an argument to
it).
To do this, add the following line to the top of {\tt dna\_markov.m}:

\item {\tt function [Pi] = dna\_markov(n)} \hfill Then {\tt dna\_markov} is
a function which needs a parameter {\tt n} (the length of the sequence to
generate) and returns a vector {\tt Pi}.
\item Change {\tt 399} to {\tt n-1}.

For a function, the variables it introduces, like {\tt Pi}, are internal to
the function unless they are explicitly passed back when the function is
done.
Just like the functions {\tt sin} and {\tt rand}, the function {\tt
dna\_markov} gives back a value, the vector {\tt Pi}.
When you go back to the command window to run it, type this:

\item {\tt Pi=dna\_markov(4000);} \hfill Semicolon to suppress displaying
{\tt Pi} itself.
However, {\tt dna\_markov} uses {\tt show} to display {\tt Pi}.
You might want to ``comment out'' that line by putting a {\tt \%} at the
beginning of it:

\item {\tt \%show(Pi,'ACGT');} \hfill

\hspace*{-0.5in}
{\bf Counting actual transitions}

The transition matrix {\tt A} says that the letter {\tt C} should be
followed by {\tt G} 60\% of the time, but in any given
sequence, the actual observed frequency will be slightly different from
that.
The program {\tt transition\_count.m} will count up how many times each
transition occurs and display the frequency of each transition.

\item {\tt transition\_count(Pi,'ACGT');} \hfill

Running {\tt dna\_markov} with a large argument (like 10000) will make the
actual transition frequencies close to those in the matrix {\tt A}.

You might want to add {\tt transition\_count} to the end of {\tt
dna\_markov}.

\hspace*{-0.5in}
{\bf Using DNA data to specify the parameters in a DNA model}

{\tt transition\_count} is especially useful when you have a set of actual
DNA data and want to make a Markov model for it.
You should go through the data, count transitions, and make a transition
matrix {\tt A} based on that.

On page 50 of {\em Biological Sequence Analysis}, there are two transition
matrices from DNA data, one marked + for transitions within CpG islands and
the other marked $-$ for non--CpG islands.

In the program {\tt dna\_markov}, below the definition of the matrix {\tt
A}, type a different definition, the matrix for the + region, as shown on
page 50:

\item {\tt A=[[0.180 0.274 0.426 0.120]; [0.171 0.368 0.274 0.188]; [0.161
0.339 0.375 0.125]; [0.079 0.355 0.384 0.182]];} \hfill

Now run {\tt dna\_markov} and {\tt transition\_count}.
You should see that {\tt C} and {\tt G} occur more frequently than {\tt A}
and {\tt T}.

\pagebreak

\hspace*{-0.5in}
{\bf Hidden Markov models}

Chapter 3 discusses how DNA appears to switch back and forth between CpG
islands and regular DNA.
As a simple example of such a phenomenon, we can write a program that
simulates a casino switching between a fair and loaded die.

Because switching the dice is hard to do without the gamblers noticing, it
isn't done that often; usually the fair die is used several times in a row,
then the loaded die, then the fair die, etc.
This can be modeled as a Markov chain having two states.
Type the following lines into a program called {\tt die\_markov.m}.
Or, save {\tt dna\_markov.m} as {\tt die\_markov.m} and make changes.

\item {\tt A  = [[.95 .05]; [.1 .9]];} \hfill
\item {\tt Pi=[];} \hfill Clear out any old value of {\tt Pi}
\item {\tt Pi(1) = rando([1 1]/2);} \hfill
\item {\tt for i=1:74,} \hfill
\item {\tt ~~Pi(i+1) = rando(A(Pi(i),:));} \hfill
\item {\tt end} \hfill
\item {\tt show(Pi,'FL')} \hfill

At each step, whichever die is being used will be rolled, and all the
gamblers get to see is what was number was rolled.
The matrix {\tt E} will be used to store the probabilities of the various
outcomes of rolling the die.
The first row will be for the fair die, the second for the loaded die.
Modify the program to read:

\item {\tt A  = [[.95 .05]; [.1 .9]];} \hfill
\item {\tt E  = [[1 1 1 1 1 1]/6; [1 1 1 1 1 5]/10];} \hfill A loaded die
lands on 6 with probability 0.5.
\item {\tt Pi=[];} \hfill Clear out any old value of {\tt Pi}
\item {\tt x=[];} \hfill Clear out any old value of {\tt x}
\item {\tt Pi(1) = rando([1 1]/2);} \hfill
\item {\tt x(1) ~= rando(E(Pi(1),:));} \hfill Use row {\tt Pi(1)} of {\tt
E} to get the probabilities when rolling the die.
\item {\tt for i=1:74,} \hfill
\item {\tt ~~Pi(i+1) = rando(A(Pi(i),:));} \hfill
\item {\tt ~~x(i+1) ~= rando(E(Pi(i+1),:));} \hfill
\item {\tt end} \hfill
\item {\tt show(Pi,'FL')} \hfill
\item {\tt show(x,'123456')} \hfill

When you run the program, you will see a sequence of F's and L's
representing which die was used and directly below these, the number which
was rolled at each step.

\hspace*{-0.5in}
{\bf The Viterbi algorithm}

The Viterbi algorithm is described on page 55 of the textbook.
Given the matrices {\tt A} and {\tt E} and an observed sequence (the rolls
of the die), it estimates what the hidden states were (fair or loaded).

{\tt dice.m} is a program that switches between fair and loaded dice, rolls
the dice, then runs the Viterbi algorithm to guess whether a fair or loaded
die was used, and marks the errors with a {\tt *}.

\item {\tt dice(75,1)} \hfill 75 die rolls.
\item {\tt dice(75,2)} \hfill 75 die rolls, but at each step, the die is
rolled twice.  This makes it easier to tell whether the die was fair or loaded.
\item {\tt dice(75,5)} \hfill 5 rolls at each step.

\end{list}
\vfill
\end{document}
